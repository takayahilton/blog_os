<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <meta http-equiv="X-Frame-Options" content="sameorigin">
  
  

  <title>
    Allocating Frames &middot; Writing an OS in Rust
  </title>

  <link rel="canonical" href="http://os.phil-opp.com/allocating-frames.html">

  
  <link rel="stylesheet" href="/css/poole.css">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="/css/syntax.css">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/images/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/images/favicon.ico">

  

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-65296949-1', 'auto');
  ga('send', 'pageview');

</script>

</head>

<body>
<div class="container content">

<header class="masthead">
  <h3 class="masthead-title">
    <a href="/" title="Home">Writing an OS in Rust</a>
    <span class="navigation">
      <small><a href="/atom.xml"><img src="/images/feed-icon.png" alt="RSS"></a></small>
    </span>
    <small>Philipp&nbsp;Oppermann's&nbsp;blog</small>
  </h3>
</header>

<main>


<article class="post">
  <h1 class="post-title">Allocating Frames</h1>
  <time datetime="2015-11-15" class="post-date">
    Nov 15, 2015
    
  </time>

  

<p>In this post we create an allocator that provides free physical frames for a future paging module. To get the required information about available and used memory we use the Multiboot information structure. Additionally, we improve the <code>panic</code> handler to print the corresponding message and source line.</p>

<p>The full source code is available on <a href="https://github.com/phil-opp/blog_os/tree/allocating_frames">Github</a>. Feel free to open issues there if you have any problems or improvements. You can also leave a comment at the bottom.</p>

<h2 id="preparation">Preparation</h2>

<p>We still have a really tiny stack of 64 bytes, which won&rsquo;t suffice for this post. So we increase it to 4096 bytes (one page) in <code>boot.asm</code>:</p>
<div class="highlight"><pre><code class="language-asm" data-lang="asm"><span></span><span class="nf">section</span> <span class="no">.bss</span>
<span class="na">...</span>
<span class="nl">stack_bottom:</span>
    <span class="nf">resb</span> <span class="mi">4096</span>
<span class="nl">stack_top:</span>
</code></pre></div>

<h2 id="the-multiboot-information-structure">The Multiboot Information Structure</h2>

<p>When a Multiboot compliant bootloader loads a kernel, it passes a pointer to a boot information structure in the <code>ebx</code> register. We can use it to get information about available memory and loaded kernel sections.</p>

<p>First, we need to pass this pointer to our kernel as an argument to <code>rust_main</code>. To find out how arguments are passed to functions, we can look at the <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">calling convention of Linux</a>:</p>

<blockquote>
<p>The first six integer or pointer arguments are passed in registers RDI, RSI, RDX, RCX, R8, and R9</p>
</blockquote>

<p>So to pass the pointer to our kernel, we need to move it to <code>rdi</code> before calling the kernel. Since we&rsquo;re not using the <code>rdi</code>/<code>edi</code> register in our bootstrap code, we can simply set the <code>edi</code> register right after booting (in <code>boot.asm</code>):</p>
<div class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span></span><span class="nl">start:</span>
    <span class="nf">mov</span> <span class="nb">esp</span><span class="p">,</span> <span class="nv">stack_top</span>
    <span class="nf">mov</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">ebx</span>       <span class="c1">; Move Multiboot info pointer to edi</span>
</code></pre></div>

<p>Now we can add the argument to our <code>rust_main</code>:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">pub</span><span class="w"> </span><span class="k">extern</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">rust_main</span><span class="p">(</span><span class="n">multiboot_information_address</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Instead of writing an own Multiboot module, we use the <a href="https://github.com/phil-opp/multiboot2-elf64">multiboot2-elf64</a> crate. It gives us some basic information about mapped kernel sections and available memory. I just wrote it for this blog post since I could not find any other Multiboot 2 crate. It&rsquo;s really ugly and incomplete, but it does its job<sup class="footnote-ref" id="fnref:fn-multiboot-crate"><a rel="footnote" href="#fn:fn-multiboot-crate">1</a></sup>.</p>

<p>So let&rsquo;s add a dependency on the git repository:</p>
<div class="highlight"><pre><code class="language-toml" data-lang="toml"><span></span><span class="c1"># in Cargo.toml</span>
<span class="p">[</span><span class="n">dependencies</span><span class="p">.</span><span class="n">multiboot2</span><span class="p">]</span>
<span class="n">git</span> <span class="o">=</span> <span class="s">&quot;https://github.com/phil-opp/multiboot2-elf64&quot;</span>
</code></pre></div>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// in src/lib.rs</span>
<span class="k">extern</span><span class="w"> </span><span class="k">crate</span><span class="w"> </span><span class="n">multiboot2</span><span class="p">;</span><span class="w"></span>
</code></pre></div>

<p>Now we can use it to print available memory areas.</p>

<h3 id="available-memory">Available Memory</h3>

<p>The boot information structure consists of various <em>tags</em>. See section 3.4 of the Multiboot specification (<a href="http://nongnu.askapache.com/grub/phcoder/multiboot.pdf">PDF</a>) for a complete list. The <em>memory map</em> tag contains a list of all available RAM areas. Special areas such as the VGA text buffer at <code>0xb8000</code> are not available. Note that some of the available memory is already used by our kernel and by the multiboot information structure itself.</p>

<p>To print all available memory areas, we can use the <code>multiboot2</code> crate in our <code>rust_main</code> as follows:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="kd">let</span><span class="w"> </span><span class="n">boot_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">unsafe</span><span class="p">{</span><span class="w"> </span><span class="n">multiboot2</span><span class="o">::</span><span class="n">load</span><span class="p">(</span><span class="n">multiboot_information_address</span><span class="p">)</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">memory_map_tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boot_info</span><span class="p">.</span><span class="n">memory_map_tag</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Memory map tag required&quot;</span><span class="p">);</span><span class="w"></span>

<span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;memory areas:&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="n">area</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">memory_map_tag</span><span class="p">.</span><span class="n">memory_areas</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;    start: 0x{:x}, length: 0x{:x}&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">area</span><span class="p">.</span><span class="n">base_addr</span><span class="p">,</span><span class="w"> </span><span class="n">area</span><span class="p">.</span><span class="n">length</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>The <code>load</code> function is <code>unsafe</code> because it relies on a valid address. Since the memory tag is not required by the Multiboot specification, the <code>memory_map_tag()</code> function returns an <code>Option</code>. The <code>memory_areas()</code> function returns the desired memory area iterator.</p>

<p>The output looks like this:</p>
<div class="highlight"><pre><span></span>Hello World!
memory areas:
    start: 0x0, length: 0x9fc00
    start: 0x100000, length: 0x7ee0000
</pre></div>

<p>So we have one area from <code>0x0</code> to <code>0x9fc00</code>, which is a bit below the 1MiB mark. The second, bigger area starts at 1MiB and contains the rest of available memory. The area from <code>0x9fc00</code> to 1MiB is not available since it contains for example the VGA text buffer at <code>0xb8000</code>. This is the reason for putting our kernel at 1MiB and not somewhere below.</p>

<p>If you give QEMU more than 4GiB of memory by passing <code>-m 5G</code>, you get another unusable area below the 4GiB mark. This memory is normally mapped to some hardware devices. See the <a href="http://wiki.osdev.org/Memory_Map_(x86)">OSDev Wiki</a> for more information.</p>

<h3 id="handling-panics">Handling Panics</h3>

<p>We used <code>expect</code> in the code above, which will panic if there is no memory map tag. But our current panic handler just loops without printing any error message. Of course we could replace <code>expect</code> by a <code>match</code>, but we should fix the panic handler nonetheless:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="cp">#[lang = </span><span class="s">&quot;panic_fmt&quot;</span><span class="cp">]</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">panic_fmt</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;PANIC&quot;</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">loop</span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Now we get a <code>PANIC</code> message. But we can do even better. The <code>panic_fmt</code> function has actually some arguments:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="cp">#[lang = </span><span class="s">&quot;panic_fmt&quot;</span><span class="cp">]</span><span class="w"></span>
<span class="k">extern</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">panic_fmt</span><span class="p">(</span><span class="n">fmt</span><span class="o">:</span><span class="w"> </span><span class="n">core</span><span class="o">::</span><span class="n">fmt</span><span class="o">::</span><span class="n">Arguments</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="o">:</span><span class="w"> </span><span class="o">&amp;</span><span class="kt">str</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="o">:</span><span class="w"> </span><span class="kt">u32</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">PANIC in {} at line {}:&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;    {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">fmt</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">loop</span><span class="p">{}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Be careful with these arguments as the compiler does not check the function signature for <code>lang_items</code>.</p>

<p>Now we get the panic message and the causing source line. You can try it by inserting a <code>panic</code> somewhere.</p>

<h3 id="kernel-elf-sections">Kernel ELF Sections</h3>

<p>To read and print the sections of our kernel ELF file, we can use the <em>Elf-sections</em> tag:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="kd">let</span><span class="w"> </span><span class="n">elf_sections_tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boot_info</span><span class="p">.</span><span class="n">elf_sections_tag</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">expect</span><span class="p">(</span><span class="s">&quot;Elf-sections tag required&quot;</span><span class="p">);</span><span class="w"></span>

<span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;kernel sections:&quot;</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="n">section</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">elf_sections_tag</span><span class="p">.</span><span class="n">sections</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;    addr: 0x{:x}, size: 0x{:x}, flags: 0x{:x}&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">section</span><span class="p">.</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">section</span><span class="p">.</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">section</span><span class="p">.</span><span class="n">flags</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>This should print out the start address and size of all kernel sections. If the section is writable, the <code>0x1</code> bit is set in <code>flags</code>. The <code>0x4</code> bit marks an executable section and the <code>0x2</code> bit indicates that the section was loaded in memory. For example, the <code>.text</code> section is executable but not writable and the <code>.data</code> section just the opposite.</p>

<p>But when we execute it, tons of really small sections are printed. We can use the <code>objdump -h build/kernel-x86_64.bin</code> command to list the sections with name. There seem to be over 200 sections and many of them start with <code>.text.*</code> or <code>.data.rel.ro.local.*</code>. This is because the Rust compiler puts e.g. each function in its own <code>.text</code> subsection. That way, unused functions are removed when the linker omits unused sections.</p>

<p>To merge these subsections, we need to update our linker script:</p>
<div class="highlight"><pre><span></span>SECTIONS {
    . = 1M;

    .boot :
    {
        KEEP(*(.multiboot_header))
    }

    .text :
    {
        *(.text .text.*)
    }

    .rodata : {
        *(.rodata .rodata.*)
    }

    .data.rel.ro : {
        *(.data.rel.ro.local*) *(.data.rel.ro .data.rel.ro.*)
    }
}
</pre></div>

<p>These lines are taken from the default linker script of <code>ld</code>, which can be obtained through <code>ld ‑verbose</code>. The <code>.text</code> <em>output</em> section contains now all <code>.text.*</code> <em>input</em> sections of the static library (and the same applies for the <code>.rodata</code> and <code>.data.rel.ro</code> sections).</p>

<p>Now there are only 12 sections left and we get a much more useful output:</p>

<p><img src="/images/qemu-memory-areas-and-kernel-sections.png" alt="qemu output" /></p>

<p>If you like, you can compare this output to the <code>objdump -h build/kernel-x86_64.bin</code> output. You will see that the start addresses and sizes match exactly for each section. The sections with flags <code>0x0</code> are mostly debug sections, so they don&rsquo;t need to be loaded. And the last few sections of the QEMU output aren&rsquo;t in the <code>objdump</code> output because they are special sections such as string tables.</p>

<h3 id="start-and-end-of-kernel">Start and End of Kernel</h3>

<p>We can now use the ELF section tag to calculate the start and end address of our loaded kernel:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="kd">let</span><span class="w"> </span><span class="n">kernel_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elf_sections_tag</span><span class="p">.</span><span class="n">sections</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">addr</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">min</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">kernel_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">elf_sections_tag</span><span class="p">.</span><span class="n">sections</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">s</span><span class="o">|</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">.</span><span class="n">max</span><span class="p">().</span><span class="n">unwrap</span><span class="p">();</span><span class="w"></span>
</code></pre></div>

<p>The other used memory area is the Multiboot Information structure:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="kd">let</span><span class="w"> </span><span class="n">multiboot_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multiboot_information_address</span><span class="p">;</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">multiboot_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multiboot_start</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">boot_info</span><span class="p">.</span><span class="n">total_size</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w"></span>
</code></pre></div>

<p>Printing these numbers gives us:</p>
<div class="highlight"><pre><span></span><span class="n">kernel_start</span><span class="o">:</span> <span class="mh">0x100000</span><span class="o">,</span> <span class="n">kernel_end</span><span class="o">:</span> <span class="mh">0x11a168</span>
<span class="n">multiboot_start</span><span class="o">:</span> <span class="mh">0x11d400</span><span class="o">,</span> <span class="n">multiboot_end</span><span class="o">:</span> <span class="mh">0x11d9c8</span>
</pre></div>

<p>So the kernel starts at 1MiB (like expected) and is about 105 KiB in size. The multiboot information structure was placed at <code>0x11d400</code> by GRUB and needs 1480 bytes. Of course your numbers could be a bit different due to different versions of Rust or GRUB (or some differences in the source code).</p>

<h2 id="a-frame-allocator">A frame allocator</h2>

<p>When using paging, the physical memory is split into equally sized chunks (normally 4096 bytes) Such a chunk is called &ldquo;physical page&rdquo; or &ldquo;frame&rdquo;. These frames can be mapped to any virtual page through page tables. For more information about paging take a peek at the <a href="/modifying-page-tables.html">next post</a>.</p>

<p>We will need a free frame in many cases. For example when want to increase the size of our future kernel heap. Or when we create a new page table. Or when we add a new kernel thread and thus need to allocate a new stack. So we need some kind of allocator that keeps track of physical frames and gives us a free one when needed.</p>

<p>There are various ways to write such a frame allocator:</p>

<p>We could create some kind of linked list from the free frames. For example, each frame could begin with a pointer to the next free frame. Since the frames are free, this would not overwrite any data. Our allocator would just save the head of the list and could easily allocate and deallocate frames by updating pointers. Unfortunately, this approach has a problem: It requires reading and writing these free frames. So we would need to map all physical frames to some virtual address, at least temporary. Another disadvantage is that we need to create this linked list at startup. That implies that we need to set over one million pointers at startup if the machine has 4GiB of RAM.</p>

<p>Another approach is to create some kind of data structure such as a <a href="http://wiki.osdev.org/Page_Frame_Allocation#Physical_Memory_Allocators">bitmap or a stack</a> to manage free frames. We could place it in the already identity mapped area right behind the kernel or multiboot structure. That way we would not need to (temporary) map each free frame. But it has the same problem of the slow initial creating/filling. In fact, we will use this approach in a future post to manage frames that are freed again. But for the initial management of free frames, we use a different method.</p>

<p>In the following, we will use Multiboot&rsquo;s memory map directly. The idea is to maintain a simple counter that starts at frame 0 and is increased constantly. If the current frame is available (part of an available area in the memory map) and not used by the kernel or the multiboot structure (we know their start and end addresses), we know that it&rsquo;s free and return it. Else, we increase the counter to the next possibly free frame. That way, we don&rsquo;t need to create a data structure when booting and the physical frames can remain unmapped. The only problem is that we cannot reasonably free frames again, but we will solve that problem in a future post (by adding an intermediate frame stack that saves freed frames).</p>

<!--- TODO link future post -->

<p>So let&rsquo;s start implementing our memory map based frame allocator.</p>

<h3 id="a-memory-module">A Memory Module</h3>

<p>First we create a memory module with a <code>Frame</code> type (<code>src/memory/mod.rs</code>):</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="cp">#[derive(Debug, PartialEq, Eq, PartialOrd, Ord)]</span><span class="w"></span>
<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">Frame</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">number</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>(Don&rsquo;t forget to add the <code>mod memory</code> line to <code>src/lib.rs</code>.) Instead of e.g. the start address, we just store the frame number. We use <code>usize</code> here since the number of frames depends on the memory size. The long <code>derive</code> line makes frames printable and comparable.</p>

<p><em>Update</em>: In a previous version, the <code>Clone</code> and <code>Copy</code> traits were derived, too. <a href="https://github.com/phil-opp/blog_os/pull/52">This was removed</a> to make the allocator interface safer.</p>

<p>To make it easy to get the corresponding frame for a physical address, we add a <code>containing_address</code> method:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">pub</span><span class="w"> </span><span class="kr">const</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4096</span><span class="p">;</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Frame</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">containing_address</span><span class="p">(</span><span class="n">address</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Frame</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Frame</span><span class="p">{</span><span class="w"> </span><span class="n">number</span><span class="o">:</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>We also add a <code>FrameAllocator</code> trait:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">FrameAllocator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">allocate_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Frame</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">deallocate_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">frame</span><span class="o">:</span><span class="w"> </span><span class="n">Frame</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>This allows us to create another, more advanced frame allocator in the future.</p>

<h3 id="the-allocator">The Allocator</h3>

<p>Now we can put everything together and create the actual frame allocator. Therefor we create a <code>src/memory/area_frame_allocator.rs</code> submodule. The allocator struct looks like this:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="kn">use</span><span class="w"> </span><span class="n">memory</span><span class="o">::</span><span class="p">{</span><span class="n">Frame</span><span class="p">,</span><span class="w"> </span><span class="n">FrameAllocator</span><span class="p">};</span><span class="w"></span>
<span class="kn">use</span><span class="w"> </span><span class="n">multiboot2</span><span class="o">::</span><span class="p">{</span><span class="n">MemoryAreaIter</span><span class="p">,</span><span class="w"> </span><span class="n">MemoryArea</span><span class="p">};</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="n">AreaFrameAllocator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">next_free_frame</span><span class="o">:</span><span class="w"> </span><span class="n">Frame</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">current_area</span><span class="o">:</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="nb">&#39;static</span><span class="w"> </span><span class="n">MemoryArea</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">areas</span><span class="o">:</span><span class="w"> </span><span class="n">MemoryAreaIter</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel_start</span><span class="o">:</span><span class="w"> </span><span class="n">Frame</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel_end</span><span class="o">:</span><span class="w"> </span><span class="n">Frame</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">multiboot_start</span><span class="o">:</span><span class="w"> </span><span class="n">Frame</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">multiboot_end</span><span class="o">:</span><span class="w"> </span><span class="n">Frame</span><span class="p">,</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>The <code>next_free_frame</code> field is a simple counter that is increased every time we return a frame. It&rsquo;s initialized to <code>0</code> and every frame below it counts as used. The <code>current_area</code> field holds the memory area that contains <code>next_free_frame</code>. If <code>next_free_frame</code> leaves this area, we will look for the next one in <code>areas</code>. When there are no areas left, all frames are used and <code>current_area</code> becomes <code>None</code>. The <code>{kernel, multiboot}_{start, end}</code> fields are used to avoid returning already used fields.</p>

<p>To implement the <code>FrameAllocator</code> trait, we need to implement the allocation and deallocation methods:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">impl</span><span class="w"> </span><span class="n">FrameAllocator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">AreaFrameAllocator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">allocate_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Frame</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// TODO (see below)</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">deallocate_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">frame</span><span class="o">:</span><span class="w"> </span><span class="n">Frame</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// TODO (see below)</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>The <code>allocate_frame</code> method looks like this:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// in `allocate_frame` in `impl FrameAllocator for AreaFrameAllocator`</span>

<span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">area</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">current_area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// &quot;Clone&quot; the frame to return it if it&#39;s free. Frame doesn&#39;t</span>
<span class="w">    </span><span class="c1">// implement Clone, but we can construct an identical frame.</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Frame</span><span class="p">{</span><span class="w"> </span><span class="n">number</span><span class="o">:</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next_free_frame</span><span class="p">.</span><span class="n">number</span><span class="w"> </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="c1">// the last frame of the current area</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">current_area_last_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">area</span><span class="p">.</span><span class="n">base_addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">area</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">Frame</span><span class="o">::</span><span class="n">containing_address</span><span class="p">(</span><span class="n">address</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">current_area_last_frame</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// all frames of current area are used, switch to next area</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">choose_next_area</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">kernel_start</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">kernel_end</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// `frame` is used by the kernel</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">next_free_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Frame</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">number</span><span class="o">:</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">kernel_end</span><span class="p">.</span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">multiboot_start</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">multiboot_end</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// `frame` is used by the multiboot information structure</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">next_free_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Frame</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">number</span><span class="o">:</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">multiboot_end</span><span class="p">.</span><span class="n">number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w"></span>
<span class="w">        </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// frame is unused, increment `next_free_frame` and return it</span>
<span class="w">        </span><span class="bp">self</span><span class="p">.</span><span class="n">next_free_frame</span><span class="p">.</span><span class="n">number</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">frame</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="c1">// `frame` was not valid, try it again with the updated `next_free_frame`</span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">allocate_frame</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="nb">None</span><span class="w"> </span><span class="c1">// no free frames left</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>The <code>choose_next_area</code> method isn&rsquo;t part of the trait and thus goes into a new <code>impl AreaFrameAllocator</code> block:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="c1">// in `impl AreaFrameAllocator`</span>

<span class="k">fn</span><span class="w"> </span><span class="n">choose_next_area</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">current_area</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">areas</span><span class="p">.</span><span class="n">clone</span><span class="p">().</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="n">area</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">area</span><span class="p">.</span><span class="n">base_addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">area</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">Frame</span><span class="o">::</span><span class="n">containing_address</span><span class="p">(</span><span class="n">address</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next_free_frame</span><span class="w"></span>
<span class="w">    </span><span class="p">}).</span><span class="n">min_by_key</span><span class="p">(</span><span class="o">|</span><span class="n">area</span><span class="o">|</span><span class="w"> </span><span class="n">area</span><span class="p">.</span><span class="n">base_addr</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">Some</span><span class="p">(</span><span class="n">area</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">current_area</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">start_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Frame</span><span class="o">::</span><span class="n">containing_address</span><span class="p">(</span><span class="n">area</span><span class="p">.</span><span class="n">base_addr</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">next_free_frame</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">start_frame</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="bp">self</span><span class="p">.</span><span class="n">next_free_frame</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_frame</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>This function chooses the area with the minimal base address that still has free frames, i.e. <code>next_free_frame</code> is smaller than its last frame. Note that we need to clone the iterator because the <a href="https://doc.rust-lang.org/nightly/core/iter/trait.Iterator.html#method.min_by_key">min_by_key</a> function consumes it. If there are no areas with free frames left, <code>min_by_key</code> automatically returns the desired <code>None</code>.</p>

<p>If the <code>next_free_frame</code> is below the new <code>current_area</code>, it needs to be updated to the area&rsquo;s start frame. Else, the <code>allocate_frame</code> call could return an unavailable frame.</p>

<p>We don&rsquo;t have a data structure to store free frames, so we can&rsquo;t implement <code>deallocate_frame</code> reasonably. Thus we use the <code>unimplemented</code> macro, which just panics when the method is called:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">impl</span><span class="w"> </span><span class="n">FrameAllocator</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">AreaFrameAllocator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">allocate_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Frame</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// described above</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">fn</span><span class="w"> </span><span class="n">deallocate_frame</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">_frame</span><span class="o">:</span><span class="w"> </span><span class="n">Frame</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">unimplemented</span><span class="o">!</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Now we only need a constructor function to make the allocator usable:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">pub</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="n">new</span><span class="p">(</span><span class="n">kernel_start</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_end</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">multiboot_start</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">multiboot_end</span><span class="o">:</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"></span>
<span class="w">      </span><span class="n">memory_areas</span><span class="o">:</span><span class="w"> </span><span class="n">MemoryAreaIter</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">AreaFrameAllocator</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AreaFrameAllocator</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">next_free_frame</span><span class="o">:</span><span class="w"> </span><span class="n">Frame</span><span class="o">::</span><span class="n">containing_address</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">current_area</span><span class="o">:</span><span class="w"> </span><span class="nb">None</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">areas</span><span class="o">:</span><span class="w"> </span><span class="n">memory_areas</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">kernel_start</span><span class="o">:</span><span class="w"> </span><span class="n">Frame</span><span class="o">::</span><span class="n">containing_address</span><span class="p">(</span><span class="n">kernel_start</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">kernel_end</span><span class="o">:</span><span class="w"> </span><span class="n">Frame</span><span class="o">::</span><span class="n">containing_address</span><span class="p">(</span><span class="n">kernel_end</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">multiboot_start</span><span class="o">:</span><span class="w"> </span><span class="n">Frame</span><span class="o">::</span><span class="n">containing_address</span><span class="p">(</span><span class="n">multiboot_start</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">multiboot_end</span><span class="o">:</span><span class="w"> </span><span class="n">Frame</span><span class="o">::</span><span class="n">containing_address</span><span class="p">(</span><span class="n">multiboot_end</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="p">};</span><span class="w"></span>
<span class="w">    </span><span class="n">allocator</span><span class="p">.</span><span class="n">choose_next_area</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">allocator</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Note that we call <code>choose_next_area</code> manually here because <code>allocate_frame</code> returns <code>None</code> as soon as <code>current_area</code> is <code>None</code>. So by calling <code>choose_next_area</code> we initialize it to the area with the minimal base address.</p>

<h3 id="testing-it">Testing it</h3>

<p>In order to test it in main, we need to <a href="https://doc.rust-lang.org/book/crates-and-modules.html#re-exporting-with-pub-use">re-export</a> the <code>AreaFrameAllocator</code> in the <code>memory</code> module. Then we can create a new allocator:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">frame_allocator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memory</span><span class="o">::</span><span class="n">AreaFrameAllocator</span><span class="o">::</span><span class="n">new</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">kernel_start</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_end</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="kt">usize</span><span class="p">,</span><span class="w"> </span><span class="n">multiboot_start</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">multiboot_end</span><span class="p">,</span><span class="w"> </span><span class="n">memory_map_tag</span><span class="p">.</span><span class="n">memory_areas</span><span class="p">());</span><span class="w"></span>
</code></pre></div>

<p>Now we can test it by adding some frame allocations:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;{:?}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">frame_allocator</span><span class="p">.</span><span class="n">allocate_frame</span><span class="p">());</span><span class="w"></span>
</code></pre></div>

<p>You will see that the frame number starts at <code>0</code> and increases steadily, but the kernel and Multiboot frames are left out (you need to allocate many frames to see this since the kernel starts at frame 256).</p>

<p>The following <code>for</code> loop allocates all frames and prints out the total number of allocated frames:</p>
<div class="highlight"><pre><code class="language-rust" data-lang="rust"><span></span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="p">..</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="kd">let</span><span class="w"> </span><span class="nb">None</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frame_allocator</span><span class="p">.</span><span class="n">allocate_frame</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">println</span><span class="o">!</span><span class="p">(</span><span class="s">&quot;allocated {} frames&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>You can try different amounts of memory by passing e.g. <code>-m 500M</code> to QEMU. To compare these numbers, <a href="http://www.wolframalpha.com/input/?i=%2832605+*+4096%29+bytes+in+MiB">WolframAlpha</a> can be very helpful.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Now we have a working frame allocator. It is a bit rudimentary and cannot free frames, but it also is very fast since it reuses the Multiboot memory map and does not need any costly initialization. A future post will build upon this allocator and add a stack-like data structure for freed frames.</p>

<h2 id="what-s-next">What&rsquo;s next?</h2>

<p>The <a href="/modifying-page-tables.html">next post</a> will be about paging again. We will use the frame allocator to create a safe module that allows us to switch page tables and map pages. Then we will use this module and the information from the Elf-sections tag to remap the kernel correctly.</p>

<h2 id="recommended-posts">Recommended Posts</h2>

<p>Eric Kidd started the <a href="http://www.randomhacks.net/bare-metal-rust/">Bare Metal Rust</a> series last week. Like this post, it builds upon the code from <a href="/printing-to-screen.html">Printing to Screen</a>, but tries to support keyboard input instead of wrestling through memory management details.</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:fn-multiboot-crate">All contributions are welcome! If you want to maintain it, please contact me!
 <a class="footnote-return" href="#fnref:fn-multiboot-crate"><sup>[return]</sup></a></li>
</ol>
</div>

</article>

<hr>
<div class="PageNavigation">
  
    <a class="prev" href="/printing-to-screen.html">&laquo; Printing to Screen</a>
  
  
    <a class="next" href="/modifying-page-tables.html">Page Tables &raquo;</a>
  
</div>
<hr>

<div id="disqus_thread"></div>
<script>
  (function() {
    
    
    if (window.location.hostname == "localhost")
        return;

    var d = document, s = d.createElement('script');

    s.src = '//phil-opp.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

</main>

<footer class="footer">
  <small>
    &copy;
    <time datetime="2016">2016</time>. All rights reserved.
    <a href="/contact.html">Contact</a>
  </small>
</footer>
</div>

</body>
</html>

